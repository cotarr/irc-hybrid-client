{
	"info": {
		"name": "irc-hybrid-client message debug",
		"description": "# Description\n\nThis collection was used during manual debugging to exercise different POST requests for the purpose of manually checking API function and data validation. \n\nIn most cases, the response to the request is returned asychronously as stream data via the websocket. The web browser should be simultaneously logged into the server. The view-raw and view-comms checkboxes will show the websocket responses.\n\n- Suggest delete cookie before running tests.\n- Assign a temporary user/password in the web server for testing.\n- In Postman, create a environment with the variables listed below. Set values to the temporary user/password and server URL.\n\n# Postman\n- Postman settings: General: Automatically follow redirects: OFF\n\n# Enviornment\n- server_URL\n- server_user1\n- server_password1\n- irc_nickname\n- irc_channel\n- sever_die (\"YES\" or \"NO\")\n\n# Instruction\n\nTo get a valid cookie, run selections 7.1, 7.2, and 7.3. After a valid cookie is present, the remainder of POST requests can be performed manually. Open a web browser concurrently with postman. Using Server --> Tools, select the View-Raw and View-Comms checkboxes to see the responses within the websocket stream. Running the tests in order will exercise the following:\n\n* Selects server index\n* Connect backend to IRC\n* JOIN an IRC channel\n* Send a channel message (PRIVMSG)\n* PART or leave the channel.\n* Remove (prune) the channel data from backend.\n* Retrieve message cache\n* Disconnect backend from IRC\n* Clear the message cache.\n* Terminate (Die) the backend web server.",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
	},
	"item": [
		{
			"name": "7.1 /logout (clear old sessions)",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Status code is 200\", function () {",
							"    pm.response.to.have.status(200);",
							"});",
							"",
							""
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"method": "GET",
				"header": [
					{
						"key": "Accept",
						"value": "text/html"
					}
				],
				"url": {
					"raw": "{{server_URL}}/logout",
					"host": [
						"{{server_URL}}"
					],
					"path": [
						"logout"
					]
				},
				"description": "Request /logout route to remove previous session authorizatin."
			},
			"response": []
		},
		{
			"name": "7.2 Debug /login (get nonce, csrfToken)",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"",
							"pm.test(\"Fail if already logged in\", function () {",
							"    // If already logged in, then redirect to main page. The nonce can not be tested.     ",
							"    let statusCode = pm.response.code;",
							"    if (statusCode === 302) {",
							"      console.log('You can not get a nonce while logged in, use /logout');",
							"    }",
							"    pm.response.to.have.status(200);",
							"});",
							"",
							"//",
							"// This assumes that the nonce is in the 23 quote delimitered string fragment.",
							"//",
							"pm.test(\"Parse the random nonce from login form\", function () {",
							"    pm.globals.unset('server_nonce');",
							"",
							"    // get response body as string (find the one with the nonce)",
							"    let arrayOfQuotedStrings = pm.response.text().split('\"')",
							"    // console.log(arrayOfQuotedStrings)",
							"    ",
							"    // Extract n-th the string fragment with nonce from array",
							"    // Example: /login-authorize?nonce=lWCgTNWj",
							"    let actionPath = arrayOfQuotedStrings[19];",
							"    // console.log(actionPath);",
							"    ",
							"    // Extract nonce as string.",
							"    // Example: lWCgTNWj",
							"    let parsedNonce = actionPath.split('=')[1];",
							"    // console.log(parsedNonce);",
							"    if ((parsedNonce) && (parsedNonce.length > 0)) {",
							"        pm.globals.set('server_nonce', parsedNonce);",
							"        console.log('/login has set lobal variable server_nonce set to: ' + pm.globals.get('server_nonce'));",
							"    }",
							"    ",
							"    pm.expect(parsedNonce).to.have.lengthOf.above(1);",
							"});",
							"",
							"pm.test(\"Extract CSRF token to global variables\", function () {",
							"    let body = pm.response.text();",
							"    let bodyArray = body.split('\\n');",
							"    let csrfToken = '';",
							"    for (let i = 0; i < bodyArray.length; i++) {",
							"        let splitByQuote = bodyArray[i].split('\"');",
							"        if ((splitByQuote.length === 7) && (splitByQuote[3] === '_csrf')) {",
							"            csrfToken = splitByQuote[5];",
							"        }",
							"    } // next i",
							"    console.log('/login has set global variable csrf_token to: ', csrfToken);",
							"    pm.globals.set('csrf_token', csrfToken);",
							"});",
							"",
							"pm.test(\"Has header to set cookie\", function () {",
							"    pm.response.to.have.header(\"Set-Cookie\");",
							"});",
							"",
							"pm.test(\"Has received cookie\", function() {",
							"    pm.expect(pm.cookies.has('irc-hybrid-client-0')).to.be.true; ",
							"});",
							"",
							"pm.test(\"Response has body\", function () {",
							"    pm.response.to.have.body();",
							"});",
							""
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"method": "GET",
				"header": [
					{
						"key": "Accept",
						"value": "text/html"
					}
				],
				"url": {
					"raw": "{{server_URL}}/login",
					"host": [
						"{{server_URL}}"
					],
					"path": [
						"login"
					]
				},
				"description": "This will request a login form, then extract the login random nonce from the login form, then temporally save the login nonce as a global variable for use in the authorize request"
			},
			"response": []
		},
		{
			"name": "7.3 Debug /login-authorize get cookie",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Status code is 302\", function () {",
							"    pm.response.to.have.status(302);",
							"});",
							"",
							"pm.globals.unset(\"server_nonce\");",
							"",
							"pm.test(\"Redirect address is /irc/webclient.html\", function () {",
							"    let location = pm.response.headers.get('Location');",
							"    pm.expect(location).to.equal('/irc/webclient.html')",
							"});",
							"",
							"pm.test(\"Has received cookie\", function() {",
							"    pm.expect(pm.cookies.has('irc-hybrid-client-0')).to.be.true; ",
							"});",
							""
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"method": "POST",
				"header": [
					{
						"key": "Content-Type",
						"value": "application/x-www-form-urlencoded"
					},
					{
						"key": "Accept",
						"value": "text/html"
					}
				],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "user",
							"value": "{{server_user1}}",
							"type": "text"
						},
						{
							"key": "password",
							"value": "{{server_password1}}",
							"type": "text"
						},
						{
							"key": "_csrf",
							"value": "{{csrf_token}}",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "{{server_URL}}/login-authorize?nonce={{server_nonce}}",
					"host": [
						"{{server_URL}}"
					],
					"path": [
						"login-authorize"
					],
					"query": [
						{
							"key": "nonce",
							"value": "{{server_nonce}}"
						}
					]
				},
				"description": "This request will submit valid username, valid password and valid random nonce. It will establish a valid session login. A redirect response will redirect the browser to the main entry HTML page."
			},
			"response": []
		},
		{
			"name": "8.1 Debug  /irc/server",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Status code is 200\", function () {",
							"    pm.response.to.have.status(200);",
							"});",
							"",
							"pm.test(\"Errpr false\", function () {",
							"    var jsonData = pm.response.json();",
							"    pm.expect(jsonData.error).to.eql(false);",
							"});",
							"",
							"pm.test(\"Server Index is 0\", function () {",
							"    var jsonData = pm.response.json();",
							"    pm.expect(jsonData.index).to.eql(0);",
							"",
							"});"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"method": "POST",
				"header": [
					{
						"key": "Accept",
						"value": "application/json"
					},
					{
						"key": "Content-Type",
						"type": "text",
						"value": "application/json"
					},
					{
						"key": "CSRF-Token",
						"value": "{{csrf_token}}",
						"type": "text"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\n  \"index\": 0\n}\n",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "{{server_URL}}/irc/server",
					"host": [
						"{{server_URL}}"
					],
					"path": [
						"irc",
						"server"
					]
				},
				"description": "The /irc/server route will submit an integer index value to the backend to select the pre-configured IRC server information. A value of -1 will select next server in rotation.\n\nThe backend will return an UPDATE request through the websocket which is not visible to postman."
			},
			"response": []
		},
		{
			"name": "8.2 Debug  /irc/getircstate 1",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Status code is 200\", function () {",
							"    pm.response.to.have.status(200);",
							"});",
							"",
							"pm.test(\"IRC connected\", function () {",
							"    var jsonData = pm.response.json();",
							"    pm.expect(jsonData.ircConnected).to.eql(false);",
							"});",
							"",
							"pm.test(\"Server index is 0\", function () {",
							"    var jsonData = pm.response.json();",
							"    pm.expect(jsonData.ircServerIndex).to.eql(0);",
							"",
							"});",
							""
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"// since postman is not capable to receive UPDATE commands on the websocket",
							"// a manual wait is included to give backend time.",
							"setTimeout(function(){}, [1000])"
						],
						"type": "text/javascript"
					}
				}
			],
			"protocolProfileBehavior": {
				"disableBodyPruning": true
			},
			"request": {
				"method": "GET",
				"header": [
					{
						"key": "Accept",
						"value": "application/json"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\n}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "{{server_URL}}/irc/getircstate",
					"host": [
						"{{server_URL}}"
					],
					"path": [
						"irc",
						"getircstate"
					]
				},
				"description": "This request would be triggered by a websocket UPDATE request which is not visible to postman. A timer is used to emulate the UPDATE request.\n\nThis request will request IRC state information. It will confirm that IRC server index zero has been selected."
			},
			"response": []
		},
		{
			"name": "8.3 Debug  /irc/connect",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Status code is 200\", function () {",
							"    pm.response.to.have.status(200);",
							"});",
							"pm.test(\"Error is false\", function () {",
							"    var jsonData = pm.response.json();",
							"    pm.expect(jsonData.error).to.eql(false);",
							"});"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							""
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"method": "POST",
				"header": [
					{
						"key": "Accept",
						"value": "application/json"
					},
					{
						"key": "Content-Type",
						"type": "text",
						"value": "application/json"
					},
					{
						"key": "CSRF-Token",
						"value": "{{csrf_token}}",
						"type": "text"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\n  \"nickName\": \"{{irc_nickname}}\",\n  \"realName\": \"{{irc_nickname}}\",\n  \"userMode\": \"\"\n}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "{{server_URL}}/irc/connect",
					"host": [
						"{{server_URL}}"
					],
					"path": [
						"irc",
						"connect"
					]
				},
				"description": "This request commands the backend to establish a connection to the IRC server and register with nickname provided.\n\nThe backend will return an UPDATE request through the websocket which is not visible to postman."
			},
			"response": []
		},
		{
			"name": "8.4 Debug  /irc/getircstate 2",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Status code is 200\", function () {",
							"    pm.response.to.have.status(200);",
							"});",
							"",
							"pm.test(\"Connecting is false\", function () {",
							"    var jsonData = pm.response.json();",
							"    pm.expect(jsonData.ircConnecting).to.eql(false);",
							"});",
							"",
							"pm.test(\"Connected is true\", function () {",
							"    var jsonData = pm.response.json();",
							"    pm.expect(jsonData.ircConnected).to.eql(true);",
							"});",
							"",
							"pm.test(\"Registered is true\", function () {",
							"    var jsonData = pm.response.json();",
							"    pm.expect(jsonData.ircRegistered).to.eql(true);",
							"});",
							"",
							"pm.test(\"Not in a channel\", function () {",
							"    var jsonData = pm.response.json();",
							"    pm.expect(jsonData.channels.length).to.eql(0);",
							"});",
							"",
							"pm.test(\"No channel states\", function () {",
							"    var jsonData = pm.response.json();",
							"    pm.expect(jsonData.channelStates.length).to.eql(0);",
							"});"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"// since postman is not capable to receive UPDATE commands on the websocket",
							"// a manual wait is included to give backend time.",
							"setTimeout(function(){}, [1000])"
						],
						"type": "text/javascript"
					}
				}
			],
			"protocolProfileBehavior": {
				"disableBodyPruning": true
			},
			"request": {
				"method": "GET",
				"header": [
					{
						"key": "Accept",
						"value": "application/json"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\n}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "{{server_URL}}/irc/getircstate",
					"host": [
						"{{server_URL}}"
					],
					"path": [
						"irc",
						"getircstate"
					]
				},
				"description": "This request would be triggered by a websocket UPDATE request which is not visible to postman. A timer is used to emulate the UPDATE request.\n\nThis request will check IRC connection state to see if the IRC server is connected."
			},
			"response": []
		},
		{
			"name": "8.5 Debug  /irc/message JOIN",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Status code is 200\", function () {",
							"    pm.response.to.have.status(200);",
							"});",
							"",
							"pm.test(\"Error is false\", function () {",
							"    var jsonData = pm.response.json();",
							"    pm.expect(jsonData.error).to.eql(false);",
							"});"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"method": "POST",
				"header": [
					{
						"key": "Accept",
						"value": "application/json"
					},
					{
						"key": "Content-Type",
						"type": "text",
						"value": "application/json"
					},
					{
						"key": "CSRF-Token",
						"value": "{{csrf_token}}",
						"type": "text"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\n  \"message\": \"JOIN {{irc_channel}}\"\n}\n",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "{{server_URL}}/irc/message",
					"host": [
						"{{server_URL}}"
					],
					"path": [
						"irc",
						"message"
					]
				},
				"description": "The /irc/message route will send valid RFC 2812 message to the backend. \n\nThis JOIN message will command the backend to join an IRC channel, name specified in the environment variables.\n\nThe backend will return an UPDATE request through the websocket which is not visible to postman."
			},
			"response": []
		},
		{
			"name": "8.6 Debug  /irc/getircstate 3",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Status code is 200\", function () {",
							"    pm.response.to.have.status(200);",
							"});",
							"",
							"pm.test(\"Channel count 1\", function () {",
							"    var jsonData = pm.response.json();",
							"    pm.expect(jsonData.channels.length).to.eql(1);",
							"});",
							"",
							"pm.test(\"Join name in channel array\", function () {",
							"    var jsonData = pm.response.json();",
							"    pm.expect(jsonData.channels[0]).to.eql(pm.environment.get(\"irc_channel\"));",
							"});",
							"",
							"pm.test(\"Channel joined is true\", function () {",
							"    var jsonData = pm.response.json();",
							"    pm.expect(jsonData.channelStates[0].joined).to.eql(true);",
							"});"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"// since postman is not capable to receive UPDATE commands on the websocket",
							"// a manual wait is included to give backend time.",
							"setTimeout(function(){}, [1000])"
						],
						"type": "text/javascript"
					}
				}
			],
			"protocolProfileBehavior": {
				"disableBodyPruning": true
			},
			"request": {
				"method": "GET",
				"header": [
					{
						"key": "Accept",
						"value": "application/json"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\n}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "{{server_URL}}/irc/getircstate",
					"host": [
						"{{server_URL}}"
					],
					"path": [
						"irc",
						"getircstate"
					]
				},
				"description": "This request would be triggered by a websocket UPDATE request which is not visible to postman. A timer is used to emulate the UPDATE request.\n\nThe IRC server state will be examined to see if the channel has been added to the channel array."
			},
			"response": []
		},
		{
			"name": "8.7. Debug  /irc/message PRIVMSG",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Status code is 200\", function () {",
							"    pm.response.to.have.status(200);",
							"});",
							"",
							"pm.test(\"Error is false\", function () {",
							"    var jsonData = pm.response.json();",
							"    pm.expect(jsonData.error).to.eql(false);",
							"});"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"method": "POST",
				"header": [
					{
						"key": "Accept",
						"value": "application/json"
					},
					{
						"key": "Content-Type",
						"type": "text",
						"value": "application/json"
					},
					{
						"key": "CSRF-Token",
						"value": "{{csrf_token}}",
						"type": "text"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\n  \"message\": \"PRIVMSG {{irc_channel}} :This is a test message (irc-hybrid-client)\"\n}\n",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "{{server_URL}}/irc/message",
					"host": [
						"{{server_URL}}"
					],
					"path": [
						"irc",
						"message"
					]
				},
				"description": "The /irc/message route will send valid RFC 2812 message to the backend. \n\nThe PRIVMSG request sends a user text message to the IRC channel."
			},
			"response": []
		},
		{
			"name": "8.8 Debug  /irc/message PART",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Status code is 200\", function () {",
							"    pm.response.to.have.status(200);",
							"});",
							"",
							"pm.test(\"Error is false\", function () {",
							"    var jsonData = pm.response.json();",
							"    pm.expect(jsonData.error).to.eql(false);",
							"});"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"method": "POST",
				"header": [
					{
						"key": "Accept",
						"value": "application/json"
					},
					{
						"key": "Content-Type",
						"type": "text",
						"value": "application/json"
					},
					{
						"key": "CSRF-Token",
						"value": "{{csrf_token}}",
						"type": "text"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\n  \"message\": \"PART {{irc_channel}}\"\n}\n",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "{{server_URL}}/irc/message",
					"host": [
						"{{server_URL}}"
					],
					"path": [
						"irc",
						"message"
					]
				},
				"description": "The /irc/message route will send valid RFC 2812 message to the backend. \n\nThis PART message will command the backend to leave (PART) the IRC channel.\n\nThe backend will return an UPDATE request through the websocket which is not visible to postman."
			},
			"response": []
		},
		{
			"name": "8.9 Debug  /irc/getircstate 4",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Status code is 200\", function () {",
							"    pm.response.to.have.status(200);",
							"});",
							"",
							"pm.test(\"Channel joined is false\", function () {",
							"    var jsonData = pm.response.json();",
							"    pm.expect(jsonData.channelStates[0].joined).to.eql(false);",
							"});",
							""
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"// since postman is not capable to receive UPDATE commands on the websocket",
							"// a manual wait is included to give backend time.",
							"setTimeout(function(){}, [1000])"
						],
						"type": "text/javascript"
					}
				}
			],
			"protocolProfileBehavior": {
				"disableBodyPruning": true
			},
			"request": {
				"method": "GET",
				"header": [
					{
						"key": "Accept",
						"value": "application/json"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\n}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "{{server_URL}}/irc/getircstate",
					"host": [
						"{{server_URL}}"
					],
					"path": [
						"irc",
						"getircstate"
					]
				},
				"description": "This request would be triggered by a websocket UPDATE request which is not visible to postman. A timer is used to emulate the UPDATE request.\n\nThe IRC state will be examined to see if the channel is marked joined: false."
			},
			"response": []
		},
		{
			"name": "8.10 Debug  /irc/prune",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Status code is 200\", function () {",
							"    pm.response.to.have.status(200);",
							"});",
							"",
							"pm.test(\"Error is false\", function () {",
							"    var jsonData = pm.response.json();",
							"    pm.expect(jsonData.error).to.eql(false);",
							"});"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"method": "POST",
				"header": [
					{
						"key": "Accept",
						"value": "application/json"
					},
					{
						"key": "Content-Type",
						"type": "text",
						"value": "application/json"
					},
					{
						"key": "CSRF-Token",
						"value": "{{csrf_token}}",
						"type": "text"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\n  \"channel\": \"{{irc_channel}}\"\n}\n",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "{{server_URL}}/irc/prune",
					"host": [
						"{{server_URL}}"
					],
					"path": [
						"irc",
						"prune"
					]
				},
				"description": "This request will command the backend to remove the specified IRC channel data from the array of active IRC channels. The user must not be present in the channel to use the prune command.\n\nThe backend will return an UPDATE request through the websocket which is not visible to postman."
			},
			"response": []
		},
		{
			"name": "8.11 Debug  /irc/getircstate 5",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Status code is 200\", function () {",
							"    pm.response.to.have.status(200);",
							"});",
							"",
							"pm.test(\"Channel array length is 0\", function () {",
							"    var jsonData = pm.response.json();",
							"    pm.expect(jsonData.channels.length).to.eql(0);",
							"});"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"// since postman is not capable to receive UPDATE commands on the websocket",
							"// a manual wait is included to give backend time.",
							"setTimeout(function(){}, [1000])"
						],
						"type": "text/javascript"
					}
				}
			],
			"protocolProfileBehavior": {
				"disableBodyPruning": true
			},
			"request": {
				"method": "GET",
				"header": [
					{
						"key": "Accept",
						"value": "application/json"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\n}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "{{server_URL}}/irc/getircstate",
					"host": [
						"{{server_URL}}"
					],
					"path": [
						"irc",
						"getircstate"
					]
				},
				"description": "This request would be triggered by a websocket UPDATE request which is not visible to postman. A timer is used to emulate the UPDATE request.\n\nThe array of active IRC channel is checked to confirm the IRC channel has been removed from the array."
			},
			"response": []
		},
		{
			"name": "8.12 Debug  /irc/cache 1",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							""
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"method": "GET",
				"header": [
					{
						"key": "Accept",
						"value": "application/json"
					}
				],
				"url": {
					"raw": "{{server_URL}}/irc/cache",
					"host": [
						"{{server_URL}}"
					],
					"path": [
						"irc",
						"cache"
					]
				},
				"description": "This is an API request to return the cache of server message (currently set to 100 messages).\n\nThe response is an array of strings."
			},
			"response": []
		},
		{
			"name": "8.13 Debug  /irc/disconnect",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							""
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"method": "POST",
				"header": [
					{
						"key": "Accept",
						"value": "application/json"
					},
					{
						"key": "Content-Type",
						"type": "text",
						"value": "application/json"
					},
					{
						"key": "CSRF-Token",
						"value": "{{csrf_token}}",
						"type": "text"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{}\n",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "{{server_URL}}/irc/disconnect",
					"host": [
						"{{server_URL}}"
					],
					"path": [
						"irc",
						"disconnect"
					]
				},
				"description": "The /irc/disconnect route will command the backend to forcibly disconnect from the IRC server. This is an emergency feature. Normally, the IRC server would be disconnected using the QUIT message."
			},
			"response": []
		},
		{
			"name": "8.14 Debug  /irc/erase",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							""
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"method": "POST",
				"header": [
					{
						"key": "Accept",
						"value": "application/json"
					},
					{
						"key": "Content-Type",
						"type": "text",
						"value": "application/json"
					},
					{
						"key": "CSRF-Token",
						"value": "{{csrf_token}}",
						"type": "text"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\n  \"erase\": \"CACHE\"\n}\n",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "{{server_URL}}/irc/erase",
					"host": [
						"{{server_URL}}"
					],
					"path": [
						"irc",
						"erase"
					]
				},
				"description": "The /irc/erase reqeust will command the backend to erase the contents of the IRC server message cache. The backend must be disconnected from the IRC server to use this command."
			},
			"response": []
		},
		{
			"name": "8.15 Debug  /irc/cache 2",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							""
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"method": "GET",
				"header": [
					{
						"key": "Accept",
						"value": "application/json"
					}
				],
				"url": {
					"raw": "{{server_URL}}/irc/cache",
					"host": [
						"{{server_URL}}"
					],
					"path": [
						"irc",
						"cache"
					]
				},
				"description": "This is a second call to retrieve the message cache. The purpose is to confirm the array is empty (length 0)."
			},
			"response": []
		},
		{
			"name": "8.16Debug  /terminate (die)",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							""
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"method": "POST",
				"header": [
					{
						"key": "Accept",
						"value": "application/json"
					},
					{
						"key": "Content-Type",
						"type": "text",
						"value": "application/json"
					},
					{
						"key": "CSRF-Token",
						"value": "{{csrf_token}}",
						"type": "text"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\n  \"terminate\": \"{{server_die}}\"\n}\n",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "{{server_URL}}/terminate",
					"host": [
						"{{server_URL}}"
					],
					"path": [
						"terminate"
					]
				},
				"description": "This is an emergency request to command the backend web server to terminate it's process."
			},
			"response": []
		}
	]
}